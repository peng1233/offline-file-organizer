param(
  [string]$In = 'docs/marketplace/assets-index_EN.md',
  [string]$Out = 'docs/marketplace/tbd-ui-report_EN.md',
  [int]$ContextLines = 0,
  # Print only the next placeholder item (single line), useful for “one tiny improvement per round” loops.
  [switch]$PrintNext
)

$ErrorActionPreference = 'Stop'

try {
  [Console]::OutputEncoding = New-Object System.Text.UTF8Encoding($false)
} catch {}

$repoRoot = Split-Path -Parent $PSScriptRoot
Set-Location -LiteralPath $repoRoot

$inPath = Join-Path $repoRoot $In
if (-not (Test-Path -LiteralPath $inPath -PathType Leaf)) {
  throw ('Missing input file: ' + $In)
}

# Read as UTF-8 (BOM/no-BOM tolerant)
$linesIn = [System.IO.File]::ReadAllLines($inPath, (New-Object System.Text.UTF8Encoding($true)))

$patterns = @(
  @{ Name = 'TBD_UI'; Regex = [regex]'\bTBD_UI\b' },
  @{ Name = '[FILL]'; Regex = [regex]'\[FILL\]' }
)

$hits = New-Object System.Collections.Generic.List[object]
$currentH1 = ''
$currentH2 = ''
$currentH3 = ''

for ($i = 0; $i -lt $linesIn.Length; $i++) {
  $line = $linesIn[$i]
  $trim = $line.Trim()

  if ($trim -match '^#\s+(.+)$') {
    $currentH1 = $Matches[1].Trim(); $currentH2 = ''; $currentH3 = ''
    continue
  }
  if ($trim -match '^##\s+(.+)$') {
    $currentH2 = $Matches[1].Trim(); $currentH3 = ''
    continue
  }
  if ($trim -match '^###\s+(.+)$') {
    $currentH3 = $Matches[1].Trim()
    continue
  }

  foreach ($p in $patterns) {
    if ($p.Regex.IsMatch($line)) {
      $hits.Add([pscustomobject]@{
        LineNumber = ($i + 1)
        Kind       = $p.Name
        H1         = $currentH1
        H2         = $currentH2
        H3         = $currentH3
        Line       = $line
      })
      break
    }
  }
}

function GetHeadingContext($h) {
  $ctxParts = @()
  if ($h.H1) { $ctxParts += $h.H1 }
  if ($h.H2) { $ctxParts += $h.H2 }
  if ($h.H3) { $ctxParts += $h.H3 }
  $ctx = ($ctxParts -join ' > ')
  if (-not $ctx) { $ctx = '(no heading context)' }
  return $ctx
}

$linesOut = New-Object System.Collections.Generic.List[string]
$linesOut.Add('# TBD_UI / [FILL] placeholder report (auto-generated)')
$linesOut.Add('')
$linesOut.Add('Generated by: scripts/marketplace-tbd-ui-report.ps1')
$linesOut.Add(('Time (local): ' + (Get-Date).ToString('yyyy-MM-dd HH:mm (K)')))
$linesOut.Add('')
$linesOut.Add('Purpose: list remaining UI-dependent placeholders to verify in Fiverr/Upwork/Toptal/Sponsors backends, then replace in assets-index_EN.md.')
$linesOut.Add('')
$linesOut.Add(('Input: ' + $In.Replace('\\','/')))
$linesOut.Add(('Total hits: ' + $hits.Count))
$linesOut.Add('')

if ($PrintNext) {
  if ($hits.Count -eq 0) {
    Write-Host 'NEXT_OK: No placeholders found.'
    exit 0
  }

  $next = ($hits | Sort-Object -Property @(
    @{ Expression = 'Kind'; Ascending = $true },
    @{ Expression = 'LineNumber'; Ascending = $true }
  ) | Select-Object -First 1)

  $loc = ($In.Replace('\\','/') + ':' + $next.LineNumber)
  $ctx = GetHeadingContext $next
  $text = $next.Line.Trim()
  Write-Host ('NEXT: ' + $next.Kind + ' | ' + $loc + ' | ' + $ctx + ' | ' + $text)
  exit 0
}

if ($hits.Count -eq 0) {
  $linesOut.Add('OK: No placeholders found.')
  $linesOut.Add('')
  $linesOut.Add('REPORT_OK')
  $linesOut.Add('')
} else {
  $linesOut.Add('## Summary')
  $linesOut.Add('')
  $linesOut.Add('- By kind:')
  foreach ($g in ($hits | Group-Object Kind | Sort-Object Name)) {
    $linesOut.Add(('  - ' + $g.Name + ': ' + $g.Count))
  }
  $linesOut.Add('')
  $linesOut.Add('- By platform (H2):')
  foreach ($g in ($hits | Group-Object H2 | Sort-Object Name)) {
    $name = $g.Name
    if (-not $name) { $name = '(no H2)' }
    $linesOut.Add(('  - ' + $name + ': ' + $g.Count))
  }
  $linesOut.Add('')

  $linesOut.Add('## Hits')
  $linesOut.Add('')
  $linesOut.Add('- Format: kind | location | context | text')
  $linesOut.Add('')

  $hitsSorted = $hits | Sort-Object -Property @(
    @{ Expression = 'Kind'; Ascending = $true },
    @{ Expression = 'LineNumber'; Ascending = $true }
  )

  foreach ($h in $hitsSorted) {
    $ctx = GetHeadingContext $h
    $text = ($h.Line.Trim())
    if ($text.Length -gt 220) { $text = $text.Substring(0, 220) + ' ...' }

    $loc = ($In.Replace('\\','/') + ':' + $h.LineNumber)
    $linesOut.Add(('- ' + $h.Kind + ' | ' + $loc + ' | ' + $ctx + ' | ' + $text))

    if ($ContextLines -gt 0) {
      $start = [Math]::Max(0, ($h.LineNumber - 1) - $ContextLines)
      $end = [Math]::Min($linesIn.Length - 1, ($h.LineNumber - 1) + $ContextLines)
      for ($j = $start; $j -le $end; $j++) {
        if ($j -eq ($h.LineNumber - 1)) { continue }
        $ctxLine = $linesIn[$j].Trim()
        if ($ctxLine -eq '') { continue }
        if ($ctxLine.Length -gt 220) { $ctxLine = $ctxLine.Substring(0, 220) + ' ...' }
        $linesOut.Add(('  - ctx line ' + ($j + 1) + ': ' + $ctxLine))
      }
    }
  }

  $linesOut.Add('')
  $linesOut.Add('## Next step')
  $linesOut.Add('')
  $linesOut.Add('Open the platform UI (do NOT click final publish/submit yet), verify the exact limit/value, then replace the placeholder in assets-index_EN.md.')
  $linesOut.Add('')
  $linesOut.Add('REPORT_OK')
  $linesOut.Add('')
}

$outPath = Join-Path $repoRoot $Out
$outDir = Split-Path -Parent $outPath
if (-not (Test-Path -LiteralPath $outDir)) {
  New-Item -ItemType Directory -Path $outDir | Out-Null
}

# UTF-8 with BOM (keeps Windows editors happy)
$utf8Bom = New-Object System.Text.UTF8Encoding($true)
[System.IO.File]::WriteAllLines($outPath, $linesOut, $utf8Bom)

Write-Host ('Wrote: ' + $Out)
Write-Host ('Total hits: ' + $hits.Count)
Write-Host 'REPORT_OK'
